// Generated by CoffeeScript 1.8.0

/*
This is queuefication module

- it create AOP wrapper for function and build queue if some queries do to function
like memoize, but for async and only in this moment
 */

(function() {
  var queueSomeRequest, _, _done_cb_builder, _keyBuilder, _keyChecker,
    __slice = [].slice;

  _ = require('lodash');

  _keyChecker = function(key, args) {
    if (!_.isString(key)) {
      return cb(TypeError("cant build cache key as String form args:\n|args| = |" + (args != null ? args.join(',') : void 0) + "|"));
    }
  };

  _keyBuilder = function(args) {
    var arg, res, _i, _len;
    res = '';
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (!_.isFunction(arg)) {
        res += arg;
      }
    }
    return res;
  };

  _done_cb_builder = function(queue_cache, key) {
    return function() {
      var data, step, _results;
      data = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      while (step = queue_cache[key].shift()) {
        _results.push(step.apply(null, _.cloneDeep(data)));
      }
      return _results;
    };
  };

  queueSomeRequest = function(methodBody) {
    var queue_cache;
    queue_cache = {};
    return function() {
      var args, cb, key, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      key = _keyBuilder(args);
      _keyChecker(key, args);
      queue_cache[key] || (queue_cache[key] = []);
      queue_cache[key].push(cb);
      if (queue_cache[key].length === 1) {
        return methodBody.apply(this, args.concat(_done_cb_builder(queue_cache, key)));
      }
    };
  };

  module.exports = {
    queueSomeRequest: queueSomeRequest
  };

}).call(this);
