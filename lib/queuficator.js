// Generated by CoffeeScript 1.9.3

/*
This is queuefication module

- it create AOP wrapper for function and build queue if some queries do to function
like memoize, but for async and only in this moment
 */

(function() {
  var _, _done_cb_builder, _keyBuilder, _keyChecker, queueSomeRequest,
    slice = [].slice;

  _ = require('lodash');

  _keyChecker = function(key, args) {
    if (!_.isString(key)) {
      return cb(TypeError("cant build cache key as String form args:\n|args| = |" + (args != null ? args.join(',') : void 0) + "|"));
    }
  };

  _keyBuilder = function(args) {
    var arg, i, len, res;
    res = '';
    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      if (!_.isFunction(arg)) {
        res += arg;
      }
    }
    return res;
  };

  _done_cb_builder = function(queue_cache, key) {
    return function() {
      var data, results, step;
      data = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      while (step = queue_cache[key].shift()) {
        results.push(step.apply(null, _.cloneDeep(data)));
      }
      return results;
    };
  };

  queueSomeRequest = function(methodBody) {
    var queue_cache;
    queue_cache = {};
    return function() {
      var args, cb, i, key;
      args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
      key = _keyBuilder(args);
      _keyChecker(key, args);
      queue_cache[key] || (queue_cache[key] = []);
      queue_cache[key].push(cb);
      if (queue_cache[key].length === 1) {
        return methodBody.apply(this, args.concat(_done_cb_builder(queue_cache, key)));
      }
    };
  };

  module.exports = {
    queueSomeRequest: queueSomeRequest
  };

}).call(this);
