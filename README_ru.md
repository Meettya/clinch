# clinch

**clinch** - еще один упаковщик ComonJS-style проектов для браузера. 

Он отлично подходит для небольших модулей благодаря малому оверхеду на имитацию require-логики.

Он отлично продходит для больших приложений благодаря возможности подмены кода модулей, эмуляции глобальных node-переменых и реализации экспорта нескольких объектов сразу.

## что в коробке?

 - `.js`      - просто упаковывается в бандл как есть
 - `.json`    - заворачивается в `module.exports` как node и делает при `require('file.json')`
 - `.coffee`  - компилируется в JavaScript
 - `.eco`     - прекомпилируется как JavaScript функция
 - `.jade`    - прекомпилируется как [client-mode](https://github.com/visionmedia/jade#a4) вариант

## а можно подключить мой любимый шаблонизатор?

Такая возможность почти есть - **clinch** с версии 0.2.5 реализует возможность подключения сторонних парсеров, но со стороны парсера должна быть поддержка предкомпиляции щаблона в функцию.

Подробности и пример - ниже, в описании метода `registerProcessor()`.

Кроме того есть [пример использования Handelbars](https://github.com/Meettya/clinch/wiki/Handlebars-template-engine-support).

### Немного про .jade

Скомпилированный [client-mode](https://github.com/visionmedia/jade#a4) шаблон может быть запрошен через `require()`. Подробнее можно посмотреть в тестах, так же пример есть на страничке wiki [jade template engine](https://github.com/Meettya/clinch/wiki/Jade-template-engine-support). В браузере необходимо загрузить `runtime.js` от **Jade**.

Кстати, как бы странно это не звучало - использование `.jade` предпочтительнее, чем `.eco`. Да, именно так - **jade** прекомпилируется в более компактную конструкцию, т.к. сервисные функции идут в его `runtime.js`. То, что он "самый медленный" - в нашем случае не совсем так, он медленный при компиляции, однако готовая функция, которую мы отдаем клиенту - быстрая. Так что скорость страдает только при сборке бандла, на что у нас есть кеш и несколько интересных идей.

## installation

    npm install clinch

## example

    #!/usr/bin/env coffee
    Clinch = require 'clinch'
    packer = new Clinch()
    pack_config = 
      bundle : 
        main : "#{__dirname}/hello_world"
    packer.buildPackage 'my_package', pack_config, (err, data) ->
      if err
        console.log 'Builder, err: ', err
      else
        console.log 'Builder, data: \n', data

Контент файла `./hellow_world`

    ###
    This is 'Hello World!' example
    ###
    module.exports = 
      hello_world : -> 'Hello World!'

Даст нам в `data` примерно такие данные

    (function() {
        'use strict';
        
    <... skip clinch header ...>

        dependencies = {};
        sources = {
    "2377150448": function(exports, module, require) {
    // /Users/meettya/github/clinch/example/hello_world/hello_world.coffee 
    /*
    This is 'Hello World!' example
    */
    module.exports = {
      hello_world: function() {
        return 'Hello World!';
      }
    };
    }};
    this.my_package = {
    "main": require(2377150448)};
    }).call(this);

И в браузере функция будет доступна вот так

    hello_world = my_package.main.hello_world

## Особенности:

### только require-based включение модулей

В отличие от [stitch](https://github.com/sstephenson/stitch) в пакет включаются только модули, которые загружаются посредством `require()` а не все, лежащие в перечисленных папках.

### честный AST-парсинг кода модулей

**clinch** проводит поиск в результирующем CommonJS-коде, что исключает появление в зависимостях закомментированных модулей и прочих странных вещей.
*Скоро появится настойка для "нечестного" (зато быстрого) поиска.*

### исходный код модулей не модифицируется

**clinch** добавляет к исходному коду модуля только комментарий с путем файла, для облегчения отладки. Сам код остается в неприкосновенности, следовательно появление ошибки в результате обработки упаковщиком маловероятно.

### но шаблоны прекомпилируются

**clinch** поддерживает шаблонные движки, прекомпилируя шаблон в быструю функцию. Попробуте **Jade**, он крут.

### есть разные версии и нет дублей

Благодаря использованию деревьев зависимостей и подмене имен файлов на их хеш от содержимого решается проблема одноименных подчиненных модулей с разной версией и исключаются дубликаты модулей, имеющих разные имена и одинаковое содержимое (это чертовски сложно объяснить, но это работает, просто поверьте).

### бандл, а не приложение

**clinch** создает бандл-пак, а не собирает приложение. В чем разница? У вас сколько угодно точек входа. Более того, можно сделать дополнительной точкой входа суб-модуль, и это никак не изменит размер получаемого пакета.

### development-mode ready

**clinch** может быть использован для development-mode http-serverа прямо из коробки. Все асинхронно, везде кеш, умная инвалидация кеша в комплекте. Объявите объект повыше и используйте для сборки кода на лету.

### кеширование модулей

Однажды "разрешенные" (с помощью `require`) модули кешируются и вне зависимости от количества обращений к модулю вы всегда имеете дело с одной и той-же копией объекта (как это и делает node.js). *Важно - если что-то пошло не так - можете выключить данную настройку, но, вероятнее всего, в вашем коде есть неоднозначности.*

### runtime aka external lib

ДА! У нас есть возможность выделить заменить boilerplate-часть бандла ссылкой на внешнюю библиотеку (идет в комплекте, полный файл и минифицированная версия). При использовании более одного бандла профит очевиден. Рекомендую к использванию.

### code coverage

**clinch** идет в комплекте с гиганским набором тестов, и мы знаем что такое regression

## API

У **clinch** очень простой API

### constructor

    packer = new Clinch clinch_options

`clinch_options` - настройки для Clinch

### buildPackage()

    packer.buildPackage package_config, cb
    # or old form, will be deprecated in new version
    packer.buildPackage package_name, package_config, cb

`package_name` - имя глобального объекта пакета, который станет корнем для всего содержимого бандла в браузере, как `$` в jQuery, коллизии имен пакетов на вашей совести. В будущих версиях будет исключена из API, используйте `package_config.package_name`

`package_config` - настройки пакета.

`cb` - стандартный коллбек, для работы с результатами, все в **clinch** асинхронно.

### registerProcessor()

    packer.registerProcessor file_extention, fn

Данный метод позволяет зарегистрировать произвольный обработчик контента файла, который будет использован для обработки файла с указанным разрешением.

`file_extention` - разрешение файла, которое будет обработано

`fn` - функция для обработки файла

Простой пример:

    # add .econ processor
    packer.registerProcessor '.econ', (file_content, filename, cb) ->
      content = Eco.precompile file_content
      cb null, "module.exports = #{content}"

Теперь **clinch** будет компилировать указаным образом все запрошенные файлы с разрешением `.econ`

Т.е. в коде модуля можно будет написать так

    template = require './template' # ./template.econ, расширение можно не указывать
    res = template data # в res будет какой-то html


### flushCache()

    packer.flushCache()

Этот метод сбрасывает кеш пакера. Обычно инвалидатор кеша в **clinch** отлично справляется со своей работой, но если вам по каким-то причинам нужно сделать принудительный ручной сброс - это просто.

### getPackageFilesList()

    packer.getPackageFilesList package_config, cb

Этот метод вернет (асинхронно) список (массив) всех файлов , которые участвуют в построении бандла.
Метод может быть полезен при создании наблюдателя над этими файлами, или для каких-то других целей.

## Settings

### clinch_options

    log           : off  # включает отладочную информацию, пока не реализовано
    strict        : on   # управляет строчкой 'use strict;' в шапке бандла
    inject        : on   # если изменить на 'off' - бандл не будет инжектить 'package_name' в глобальную переменную. 
    runtime       : off  # задействуйте эту настройку для использования внешнего файла с реализацией require 
    cache_modules : on   # по умолчанию все модули, разрешенные единожды require будут закешированы (если у вас появятся какие-то проблемы - выключите опцию и сообщите, пожалуйста, мне)

    ###
    эти настройки могут быть переданы функции jade.compile()
    ###
    jade :
      pretty : on
      self : on
      compileDebug : off

### package_config

пример доступных настроек пакета с комментариями
    
    ###
    Может отсутствовать, в таком случае `clinch` или инжектит ВСЕ перечисленные в `bundle` элементы в глобаль, или, если у нас `inject : off` - просто делает все элементы локальными для пакета (такую технику можно использовать для виджетов, которые сами инициируют себя по содержанию страницы, ninja-hide-style)
    ###
    package_name : 'bundle_pack_name'

    # локальные для бандла настройки
    strict : on   # управляет строчкой 'use strict;' в шапке бандла
    inject : on   # если изменить на 'off' - бандл не будет инжектить 'package_name' в глобальную переменную. 
    runtime       : off  # задействуйте эту настройку для использования внешнего файла с реализацией require 
    cache_modules : on   # по умолчанию все модули, разрешенные единожды require будут закешированы (если у вас появятся какие-то проблемы - выключите опцию и сообщите, пожалуйста, мне)

    ###
    Ветка bundle перечисляет модули, которые будут включены в пакет 
    И будут доступны в браузере из глобального объекта пакета
    ###
    bundle :
      main : './src'              # -> my_package.main
      helper : './src/lib/helper' # -> my_package.helper

    ###
    Ветка replacement перечисляет модули, которые будут подменены.
    Кроме того здесь следует указывать любые node.js - core модули,
    так как их импорт по умолчанию не производтся.
    ###
    replacement :
      util : './node_modules/js-util'

    ###
    Ветка requireless может быть использована для ускорения сборки пакета
    перечисленные модули не будут разбираться на предмет наличия в них
    require, что существенно сокращает время сборки, особенно с большими файлами
    ###
    requireless : [
      'lodash'
    ]

    ###
    Ветка environment может использоваться для имитации node.js окружения,
    ключи становятся локальными для пакета переменными, с похожим для node.js поведением.
    Используйте осторожно, точно понимая что вы делаете.
    ###
    environment :
      process : './node/js-process'
      console : './node_modules/console-shim'

    ###
    Ветка exclude используется для исключения модулей из пакета,
    однако ее ценность выглядит сомнительной, возможно в дальнейшем
    она будет исключена. Используйте replacement и fake-модули.
    ###
    exclude : [
      'underscore'
    ]

## Что на выходе?

Результатом работы **clinch** является SIF бандл-пак, который инжектит в this ключ с именем бандл-пака, в содержимом будут ключи, перечисленные в bundle-ветке настроек.

Если проще, то после загрузки файла в браузер необходимые модули станут доступны как то так - `var main = my_package.main`

Кроме того у нас есть настройка `inject` которая упрявляет инжектом и можно  оставить глобальное пространство чистым, используя привязку, положим, виджетов к `data-attribute`.

## У меня ничего не работает

Во-первых ваш код должен работать в node.js, например проходить тесты. Если рабочий код после упаковки становится неработоспособным - возможно следует указать замену node.js-специфичным модулям или core-модулям.

Если код выглядит переносимым, но тем не менее не хочет работать в браузере - свяжитесь со мной, возможно я где-то ошибся в **clinch**, на данный момент это всего лишь бета.

Кроме того можете проверить директории `example` и `test` на предмет подсказок и примеров использования.

## Примеры

Смотри `example` или `test` директории.

Кроме того несколько простых примеров результата доступны online тут - [clinch_demo](http://meettya.github.com/clinch_demo/index.html).

Так же **clinch** был использован для упаковки проекта [TinyData](http://meettya.github.com/TinyData/demo.html), смотри исходники на странице или [packed lib](https://github.com/Meettya/TinyData/blob/master/lib_browser/tinydata.js)

## Благодарности

[Shuvalov Anton](https://github.com/shuvalov-anton)

[Simakov Konstantin](https://github.com/GigabyteTheOne)
